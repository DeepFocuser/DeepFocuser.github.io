<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://deepfocuser.github.io/</id><title>DeepFocuser</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-11-29T05:31:04+09:00</updated> <author> <name>DeepFocuser</name> <uri>https://deepfocuser.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://deepfocuser.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://deepfocuser.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2021 DeepFocuser </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>DETR set prediction loss</title><link href="https://deepfocuser.github.io/posts/detr/" rel="alternate" type="text/html" title="DETR set prediction loss" /><published>2021-11-23T20:00:00+09:00</published> <updated>2021-11-29T04:46:26+09:00</updated> <id>https://deepfocuser.github.io/posts/detr/</id> <content src="https://deepfocuser.github.io/posts/detr/" /> <author> <name>JONGGON KIM</name> </author> <category term="AI" /> <category term="컴퓨터 비전" /> <summary> DETR 논문 바로가기 DETR 논문을 읽었다. ‘vision 문제중 하나인 object detector를 Transformer로 풀었다 NMS도 필요없다. 또 panoptic segmentation 에까지 확장 가능하다.’ 라는 내용인데, 읽으면서 몇가지 의문이 들었다. 구현을 염두해둔 의문(positional encoding은 어떻게 코드로 적용할까나? 번역, 챗봇과 다른 vision문제에서 Transformer는 Attention map을 어떻게 그릴까나?)과 DETR에서 가장 중요한 내용인 hungarian algorithm 이다. hungarian algorithm에 관련된 의문을 제외하곤 페이스북의 공식 DETR 깃허브의 코드들을 보면서 의문점을 해결했다. DETR Atten... </summary> </entry> <entry><title>Hungarian algorithm</title><link href="https://deepfocuser.github.io/posts/hungarian-algorithm/" rel="alternate" type="text/html" title="Hungarian algorithm" /><published>2021-11-22T20:00:00+09:00</published> <updated>2021-11-29T03:24:17+09:00</updated> <id>https://deepfocuser.github.io/posts/hungarian-algorithm/</id> <content src="https://deepfocuser.github.io/posts/hungarian-algorithm/" /> <author> <name>JONGGON KIM</name> </author> <category term="알고리즘" /> <category term="코드 조각" /> <summary> DETR 논문을 읽기에 앞서 Hungarian algorithm 알고리즘에 대한 이해가 필요하여 정리해본다. Hungarian algorithm 알고리즘 코드 구현은 파이썬에서 “from scipy.optimize import linear_sum_assignment” 로 사용할 수 있다. 자세한 사용 방법은 여기를 보면 된다. Hungarian algorithm Hungarian method는 다항 시간에 할당 문제를 해결하는 방법인 동시에 later primal–dual methods 예측(???)하는 조합 최적화 알고리즘이다.(예전에 배웠던것 같은데 기억이…) 이 알고리즘은 Harold Kuhn이 1955년에 개발했다. Hungarian method 라는 이름이 붙은 이유는 이 알고리즘이 ... </summary> </entry> <entry><title>Maximum Bipartite Matching</title><link href="https://deepfocuser.github.io/posts/maximum-bipartite-matching/" rel="alternate" type="text/html" title="Maximum Bipartite Matching" /><published>2021-11-05T20:00:00+09:00</published> <updated>2021-11-29T04:46:26+09:00</updated> <id>https://deepfocuser.github.io/posts/maximum-bipartite-matching/</id> <content src="https://deepfocuser.github.io/posts/maximum-bipartite-matching/" /> <author> <name>JONGGON KIM</name> </author> <category term="알고리즘" /> <category term="코드 조각" /> <summary> DETR 논문을 읽기에 앞서 Maximum Bipartite Matching 알고리즘에 대한 이해가 필요하여 정리해본다. 사실 Optimal Bipartite Matching-Hungarian algorithm에 대한 내용이 필요하다. DETR을 이해하는데 있어 Maximum Bipartite Matching이 필요한 것은 아니지만 남겨놓자. Maximum Bipartite Matching 알고리즘 코드 구현은 DFS 코드를 기반으로 한다. Maximum Bipartite Matching(이분 매칭) 두 개의 정점 그룹이 존재할 때 모든 간선(경로)의 용량이 1이면서 양쪽 정점이 서로 다른 그룹에 속하는 그래프를 이분 그래프(Bipartite Graph)라고 한다. 예를 들어, 한쪽 그룹은 X 그... </summary> </entry> <entry><title>BFS DFS</title><link href="https://deepfocuser.github.io/posts/bfsdfs/" rel="alternate" type="text/html" title="BFS DFS" /><published>2021-11-05T20:00:00+09:00</published> <updated>2021-11-06T00:02:23+09:00</updated> <id>https://deepfocuser.github.io/posts/bfsdfs/</id> <content src="https://deepfocuser.github.io/posts/bfsdfs/" /> <author> <name>JONGGON KIM</name> </author> <category term="알고리즘" /> <category term="코드 조각" /> <summary> BFS : 넓이 우선 탐색 / for문을 이용한 방식(1가지) DFS : 깊이 우선 탐색 / for문과 재귀를 이용한 방식(2가지) python 코드 구현 from collections import deque graph = { 'A': ['B'], 'B': ['A', 'C', 'H'], 'C': ['B', 'D'], 'D': ['C', 'E', 'G'], 'E': ['D', 'F'], 'F': ['E'], 'G': ['D'], 'H': ['B', 'I', 'J', 'M'], 'I': ['H'], 'J': ['H', 'K'], 'K': ['J', 'L'], 'L': ['K'], 'M': ['H'] } p... </summary> </entry> <entry><title>Beam Search Decoder</title><link href="https://deepfocuser.github.io/posts/beamsearch/" rel="alternate" type="text/html" title="Beam Search Decoder" /><published>2021-10-07T20:00:00+09:00</published> <updated>2021-10-26T20:29:07+09:00</updated> <id>https://deepfocuser.github.io/posts/beamsearch/</id> <content src="https://deepfocuser.github.io/posts/beamsearch/" /> <author> <name>JONGGON KIM</name> </author> <category term="AI" /> <category term="자연어 처리" /> <summary> https://machinelearningmastery.com/beam-search-decoder-natural-language-processing/ 를 참고 Beam Search Decoder Beam Search는 Greedy Search 알고리즘(k=1)을 확장한 것이며, output sequences 의 리스트를 반환한다. beam search는 가능한 모든 단계(경로 를 탐색하고, k개를 유지한다. k는 사용자가 설정하는 hyper-parameter이며 beam의 수 또는 sequence 확률을 통한 병렬 탐색을 제어한다. 기계번역 작업에서는 보통 k=5 or k=10을 사용 한다. k가 크면 여러 candidate sequence들이 target sequence와 매칭될 가능... </summary> </entry> </feed>
